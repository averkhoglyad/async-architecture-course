### Auth service
Для auth первоначально планировал использовать готовое решение типа keycloak, 
а cud-события по изменению пользователя стримить с помощью kafka-connect, но потом решил разобраться в 
Spring Authentication Service и сделать всё явно руками (был ещё вариант написать плагин к keycloak, 
но это уже особый вид самоистязания). Из коробки нет UI и методов для CRUD-операций, 
но реализовать это не составляет проблемы. Ещё из минусов для текущей реализации - поддерживается только oAuth2.1,
где нет `password` и `implicit` flow, поэтому для получения jwt и проверки аутентификации пришлось немного плясать с бубном
и эмулировать поведение пользователя и страницы браузера, отлавливая редиректы.
Для будущих тестов я всё-таки реализую заглушку, чтобы получать токен по пользователю.

Сервис рассылает только сообщения на CUD-события по Пользователю (User), не уверен имеет ли смысл посылать login, 
т.к. по идее он никому кроме auth-сервиса не нужен.

### Task tracker
Аутентификация реализована на основе jwt в хедере запроса. В случае удаления пользователя, данные из БД не удаляю, но 
ставлю маркер, что пользователь больше не активен. Вопрос, что делать, если поменяется роль пользователя не прорабатывал,
но это вроде выходит за рамки нашего скоупа (теоретически, можно реассайнить таски на других пользователей). 
Также не успел переделать и добавить публичный ИД (доделаю в ближайшее время), у меня используются UUID, 
которые уникальны в пределах всей системы и использование других ИД мне изначально показалось излишним.
Интеграцию с Кафкой не успел проверить, настройки взял из другого своего проекта, так что теоретически 
всё должно завестись и заработать, но проверить и отладить надо будет
(В теории нет разницы между теорией и практикой, но на практике она имеется, но на практике), 
а ещё надо бы обновить версию Кафки.

*CUD:*

- `Streaming-Task` - События по Задачам (Task), по факту это только создание. Не уверен, нужно ли посылать CUD-события 
  в случае изменения статуса и/или закрытия Задачи, а также при реасайне пользователя. 
  Я решил, что это не изменение данных самой Задачи и относится только к бизнес-событиям 
  (поправь, если я не прав или выскажи своё мнение)

*BE:*

- `TaskLifecycle` - События связанные с жизненным циклом Задачи. 
  Сейчас включают 3 типа: создание, реассайн (shuffle) и закрытие Задачи. В сообщении отсылается минимально необходимый набор данных.
  Пока для себя не решил как буду обрабатывать, сериализовать/десериализовать эти сообщения, так что в будущем детали могут поменяться,
  но не концептуально


### Принятые соглашения
По договоренности голосов в моей голове принято решение, что топики в Кафке для CUD-событий будут именоваться с префиксом
`Streaming-` и далее наименование доменной сущности в CamelCase (например, `Streaming-User`). В сообщениях о CUD-событиях 
передается атрибут `action` которое принимает возможные значения `CREATED`, `UPDATED`, `DELETED`. Данные правила будут 
использоваться для всех CUD-событий, всех сущностей во всей системе. Именование биндингов в настройках сервисов
повторяет название топика без не alphanumeric-символов в camelCase. Именование топиков для бизнес-событий описывают
бизнес-процесс или сферу к которым они относятся в CamelCase (например, `TaskLifecycle`).

### Прочее
Не вошло в данный PR, но есть в ветке main:

- Конфиги для с которыми запускаются сервисы (настроенные имена топиков в Кафке, надо было предусмотреть чтобы оно было в PR)
- Миграции реализованы через Liquibase, много xml, поэтому тоже сразу отправил в main
- Тесты писал под HTTP Client в IntellijIDEA, сохранено в test.http файлах в каждом сервисе.
- Прочие полезные утилиты, хелперы и другой технический код
- Настройки docker-compose для локального запуска находятся в папке docker в ветке main. 
На данный момент там только Кафка, база используется локальная, т.к. уже есть и не было потребности. 

Сборку в образ самих сервисов и их запуск в докере не проверял, есть в планах в расширенной реализации.
