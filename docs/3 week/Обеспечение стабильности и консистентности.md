### Обработка ошибок при отправке событий

Для того чтобы гарантировать доставку событий, включаем `ack`=`ALL`. В сам метод отправки события добавляем retry, в случае ошибки, отключаем его по circuit breaker, добавляем fallback метод для сохранения события (в БД или Redis) для повторной отправки события позже. Далее в бэкграунде отдельный воркер повторяет отправку упавших сообщений  с некоторой увеличивающейся периодичностью. Если в течение суток сообщение не отправилось или "очередь" заполнилась - бьём тревогу. Для того чтобы бить тревогу, добавляем Graphana и прочие инструменты для отслеживания состояния системы. Так же там можно отображать метрики и прочую информацию о сервисах, получая её с помощью actuator-методов.

### Обработка ошибок при получении событий

Чтобы не "повесить" обработчик, следует отлавливать все ошибки (как минимум десериализации), иначе выполнение зациклится и будет пытаться получить и обработать сообщение повторно. Я ничего не придумал лучше, чем отправлять все упавшие события в отдельную БД (или очередь???), чтобы разгрести их позже. В любом случае невозможность обработать полученное сообщение - это переход в режим тревоги.

### Тестирование

Само собой разумеющимся является покрытие кода юнит-тестами + функциональные/модульные (если не для всего функционала, то для критического). Я приверженец того, что каждый сервис должен быть протестирован на выполнение заданного контракта на входящие и исходящие команды и события, т.е. на заданную команду ожидаем получения правильного события с правильными данными (черный ящик + заранее задано состояние). Конечно, это не гарантирует правильной работы всей системы, но мы гарантируем работу отдельного его модуля. Если есть возможность поднять тестовый стенд - это хорошо, но не всегда возможно (И это уже задача QA).

### Состояние системы в Д/З
Я не добавлял эту логику в Д/З. Так же я для простоты реализации вывода денег с баланса по крону сделал её максимально тупой - по крону просто берем N пользователей с положительным балансом пока они есть и для них выводим. Проблемы с этой реализацией:
- при параллельном запуске нескольких инстансов пользователи будут обрабатываться несколько раз
- если пользователь активен, баланс может измениться в период выполнения этой задачи

Для решения первой проблемы мы можем:
- вынести в отдельный сервис, который гарантировано запущен в 1 экземпляре, но это кажется чрезмерным
- добавить колонку с лочкой в табличке БД и первый сервис который её "захватил" будет выполнять, остальные - отвалились (пока склоняюсь к этому варианту)
- использовать внешний крон (из ОС, например) и выполнять POST-запрос через LB для запуска воркера, что гарантировано запустит только один инстанс

Для решения второй проблемы я планировал использовать оптимистичные лочки: добавить поле с таймстемпом последнего вывода денег, при выборке фильтровать по нему, а при выводе денег - обновлять. Это кажется самый простой способ.
